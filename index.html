<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual Flashcard App</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    .perspective-1000 {
      perspective: 1000px;
    }
    .transform-style-preserve-3d {
      transform-style: preserve-3d;
    }
    .backface-hidden {
      backface-visibility: hidden;
    }
    .rotate-y-180 {
      transform: rotateY(180deg);
    }
    /* Fix for card flip */
    .card-front {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      z-index: 1; /* Ensure front is initially visible */
    }
    .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      transform: rotateY(180deg);
    }
    /* Custom scroll styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    /* Smooth transitions */
    .transition-transform {
      transition: transform 0.6s; /* Slightly slower flip */
    }
    /* Sidebar transition */
    .sidebar-transition {
      transition: transform 0.3s ease-in-out;
    }
    .sidebar-open {
      transform: translateX(0);
    }
    .sidebar-closed {
      transform: translateX(-100%);
    }
    /* Keep sidebar visible on medium screens and up when closed */
    @media (min-width: 768px) {
      .sidebar-closed {
        transform: translateX(0); /* Sidebar stays visible */
      }
      /* Adjust main content margin based on sidebar visibility */
      .main-content-shifted {
        margin-left: 16rem; /* 64 * 0.25rem = 16rem */
      }
      .main-content-unshifted {
        margin-left: 0;
      }
    }
    .main-content-transition {
      transition: margin-left 0.3s ease-in-out;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen overflow-x-hidden">
  <div id="root"></div>

  <script type="text/babel">
    // Sample data - this would be loaded from a file in a real application
    const sampleData = `front,back,category,subcategory
"What is Data Manipulation in the context of GIS?","Data manipulation includes the theories and techniques for managing the entire data lifecycle, from data collection to data format conversion, from data storage to data sharing and retrieval, to data provenance, data quality control, and data curation for long-term data archival and preservation.","Core Concepts","What is Data Manipulation?"
"What is Georeferencing in GIS?","Georeferencing is a crucial process that aligns spatial data, such as satellite images or scanned maps, with real-world coordinates, placing them in their correct spatial location within a map coordinate system.","Core Concepts","Georeferencing"
"What is an Affine Transformation?","Affine Transformation includes scaling, rotation, translation, and skewing. It preserves straight lines and is commonly used for georeferencing.","Core Concepts","Transformation Methods"
"What is a Polynomial Transformation?","Polynomial transformations (first-order, second-order, etc.) adjust the shape of the raster more flexibly. They are useful when the relationship between control points is nonlinear.","Core Concepts","Transformation Methods"`;

    const App = () => {
      const [flashcards, setFlashcards] = React.useState([]);
      const [currentCardIndex, setCurrentCardIndex] = React.useState(0);
      const [isFlipped, setIsFlipped] = React.useState(false);
      const [categories, setCategories] = React.useState([]);
      const [selectedCategory, setSelectedCategory] = React.useState('All');
      const [filteredCards, setFilteredCards] = React.useState([]);
      const [loading, setLoading] = React.useState(true);
      const [importFormat, setImportFormat] = React.useState('csv');
      const [errorMessage, setErrorMessage] = React.useState('');
      const [notification, setNotification] = React.useState('');
      // Sidebar state default to closed on mobile, open on desktop
      const [sidebarOpen, setSidebarOpen] = React.useState(window.innerWidth >= 768);

      // New state for saved files
      const [savedFiles, setSavedFiles] = React.useState([]);
      const [activeFileIndex, setActiveFileIndex] = React.useState(-1);

      const fileInputRef = React.useRef(null);

      // Function to clean text and fix encoding issues
      const cleanText = (text) => {
        if (!text) return '';

        // Replace common problematic characters and encoding issues
        return text
          // Replace   and other common encoding issues
          .replace(/ /g, '')
          .replace(/[\u2018\u2019]/g, "'") // Smart single quotes
          .replace(/[\u201C\u201D]/g, '"') // Smart double quotes
          .replace(/\u2026/g, '...') // Ellipsis
          .replace(/\u2013/g, '-') // En dash
          .replace(/\u2014/g, '--') // Em dash
          .replace(/\u00A0/g, ' ') // Non-breaking space
          .replace(/\u2022/g, '*') // Bullet
          .replace(/[\u00AB\u00BB]/g, '"') // Guillemets
          .replace(/[\u2039\u203A]/g, "'") // Single guillemets
          // You can add more replacements as needed
          .trim();
      };

      const parseMarkdownData = (text) => {
        // Clean the text before parsing
        text = cleanText(text);

        const frontBackPairs = [];
        let allCategories = new Set(); // Use Set for uniqueness
        let currentCategory = 'Uncategorized';
        let currentSubcategory = '';

        // Extract categories and subcategories
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          // Check for main category
          const categoryMatch = line.match(/^## (.+)$/);
          if (categoryMatch) {
            currentCategory = categoryMatch[1].trim();
            allCategories.add(currentCategory);
            currentSubcategory = ''; // Reset subcategory when main category changes
            continue;
          }

          // Check for subcategory
          const subcategoryMatch = line.match(/^### (.+)$/);
          if (subcategoryMatch) {
            currentSubcategory = subcategoryMatch[1].trim();
            continue;
          }

          // Check for flashcard content
          if (line.toLowerCase().startsWith('**front:**')) {
            let frontContent = line.substring('**Front:**'.length).trim();

            // Look for the corresponding Back content
            let backContent = '';
            let j = i + 1;
            while (j < lines.length && !lines[j].trim().toLowerCase().startsWith('**front:**')) {
                const nextLine = lines[j].trim();
                if (nextLine.toLowerCase().startsWith('**back:**')) {
                    backContent = nextLine.substring('**Back:**'.length).trim();
                    // Collect additional lines of the back content until next Front or category marker or empty line
                    j++;
                    while (j < lines.length && lines[j].trim() !== '' && !lines[j].trim().startsWith('## ') && !lines[j].trim().startsWith('### ') && !lines[j].trim().toLowerCase().startsWith('**front:**')) {
                      backContent += '\n' + lines[j].trim();
                      j++;
                    }
                    break; // Found back, stop searching
                }
                j++;
            }

            if (backContent) {
              frontBackPairs.push({
                front: cleanText(frontContent),
                back: cleanText(backContent),
                category: currentCategory,
                subcategory: currentSubcategory
              });
              i = j - 1; // Move to the last line processed for back content
            }
          }
        }

        return { cards: frontBackPairs, categories: Array.from(allCategories) };
      };

      const parseCsvData = (text) => {
        // Clean the text before parsing
        text = cleanText(text);

        const result = Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          transformHeader: header => header.trim().toLowerCase(), // Normalize headers
        });

        if (result.errors.length > 0) {
          console.warn('CSV Parsing warnings:', result.errors);
          // Allow proceeding even with errors if data exists
        }

        if (!result.data || result.data.length === 0) {
             throw new Error('No data found in CSV file.');
        }

        if (!result.meta.fields.includes('front') || !result.meta.fields.includes('back')) {
          throw new Error('CSV must contain at least "front" and "back" columns (case-insensitive)');
        }

        const frontBackPairs = result.data.map(row => ({
          front: cleanText(row.front),
          back: cleanText(row.back),
          category: cleanText(row.category) || 'Uncategorized',
          subcategory: cleanText(row.subcategory) || ''
        }));

        const allCategories = [...new Set(frontBackPairs.map(card => card.category))].filter(Boolean).filter(cat => cat !== 'Uncategorized');

        return { cards: frontBackPairs, categories: allCategories };
      };

      const parseJsonData = (text) => {
        try {
          // Clean the text before parsing (may help with BOM or leading/trailing whitespace)
          text = cleanText(text);

          let data;
          try {
             data = JSON.parse(text);
          } catch (parseError) {
              throw new Error('Invalid JSON format: ' + parseError.message);
          }


          if (!Array.isArray(data)) {
            throw new Error('JSON data must be an array of flashcard objects');
          }

          const frontBackPairs = data.map(item => ({
            front: cleanText(item.front || item.question || ''),
            back: cleanText(item.back || item.answer || ''),
            category: cleanText(item.category) || 'Uncategorized',
            subcategory: cleanText(item.subcategory) || ''
          }));

          if (frontBackPairs.some(card => !card.front || !card.back)) {
            console.warn('Some JSON objects missing front/back or question/answer fields');
            // Allow proceeding, filter out invalid cards later if needed
          }
          const validPairs = frontBackPairs.filter(card => card.front && card.back);

          if (validPairs.length === 0) {
              throw new Error('No valid flashcards with both front and back found in JSON data.');
          }

          const allCategories = [...new Set(validPairs.map(card => card.category))].filter(Boolean).filter(cat => cat !== 'Uncategorized');

          return { cards: validPairs, categories: allCategories };
        } catch (error) {
           // Catch errors from JSON.parse or validation
           throw new Error('Error processing JSON: ' + error.message);
        }
      };

      React.useEffect(() => {
        loadInitialData();
         // Add resize listener to handle sidebar state changes
        const handleResize = () => {
            if (window.innerWidth >= 768) {
                setSidebarOpen(true); // Keep open on desktop unless explicitly closed
            } else {
                setSidebarOpen(false); // Default closed on mobile
            }
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      const loadInitialData = () => {
        try {
          setLoading(true);
          const { cards, categories } = parseCsvData(sampleData);

          setCategories(['All', ...categories]);
          setFlashcards(cards);
          setFilteredCards(cards); // Set filtered cards initially
          setCurrentCardIndex(0); // Reset index
          setIsFlipped(false); // Reset flip state
          setErrorMessage('');

          // Add sample data to saved files
          const sampleFile = {
              name: 'Sample Data (CSV)',
              format: 'csv',
              content: sampleData,
              cardCount: cards.length,
              categories: categories,
              date: new Date(),
              isDefault: true
          };
          setSavedFiles([sampleFile]);
          setActiveFileIndex(0); // Set the sample data as active
          setImportFormat('csv'); // Match the format of the loaded sample

        } catch (error) {
          console.error('Error parsing flashcard data:', error);
          setErrorMessage('Could not load initial data: ' + error.message);
          setFlashcards([]);
          setFilteredCards([]);
          setSavedFiles([]); // Clear saved files on error loading initial
          setActiveFileIndex(-1);
        } finally {
          setLoading(false);
        }
      };

      React.useEffect(() => {
        let newFilteredCards;
        if (selectedCategory === 'All') {
          newFilteredCards = flashcards;
        } else {
          newFilteredCards = flashcards.filter(card => card.category === selectedCategory);
        }
        setFilteredCards(newFilteredCards);
        setCurrentCardIndex(0);
        setIsFlipped(false);
      }, [selectedCategory, flashcards]);

      const flipCard = () => {
        setIsFlipped(!isFlipped);
      };

      const nextCard = () => {
        if (currentCardIndex < filteredCards.length - 1) {
          setCurrentCardIndex(currentCardIndex + 1);
          setIsFlipped(false);
        } else {
            // Optional: Loop back to start
            // setCurrentCardIndex(0);
            // setIsFlipped(false);
        }
      };

      const prevCard = () => {
        if (currentCardIndex > 0) {
          setCurrentCardIndex(currentCardIndex - 1);
          setIsFlipped(false);
        } else {
             // Optional: Loop back to end
             // if (filteredCards.length > 0) {
             //   setCurrentCardIndex(filteredCards.length - 1);
             //   setIsFlipped(false);
             // }
        }
      };

      const shuffleCards = () => {
        const shuffled = _.shuffle([...filteredCards]);
        setFilteredCards(shuffled);
        setCurrentCardIndex(0);
        setIsFlipped(false);
        setNotification('Cards shuffled!');
        setTimeout(() => setNotification(''), 2000);
      };

      const handleCategoryChange = (e) => {
        setSelectedCategory(e.target.value);
      };

      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        setLoading(true);
        setErrorMessage('');
        setNotification('');

        // Determine format from extension if not explicitly set (or use selected format)
        const fileExtension = file.name.split('.').pop().toLowerCase();
        let currentParseFormat = importFormat;
        if (['csv', 'json', 'md', 'txt'].includes(fileExtension)) {
            if (fileExtension === 'md' || fileExtension === 'txt') {
                 currentParseFormat = 'markdown';
            } else {
                 currentParseFormat = fileExtension;
            }
            // Update the radio button selection to match detected format
            setImportFormat(currentParseFormat);
        } else {
             setErrorMessage(`Unsupported file type: .${fileExtension}. Please select CSV, JSON, or Markdown/Text.`);
             setLoading(false);
             e.target.value = ''; // Reset file input
             return;
        }


        const reader = new FileReader();

        reader.onload = (event) => {
          try {
            const content = event.target.result;
            let result;

            if (currentParseFormat === 'csv') {
              result = parseCsvData(content);
            } else if (currentParseFormat === 'json') {
              result = parseJsonData(content);
            } else { // markdown
              result = parseMarkdownData(content);
            }

            if (!result || result.cards.length === 0) {
              setErrorMessage('No valid flashcards found in file.');
            } else {
              const uniqueCategories = ['All', ...new Set(result.cards.map(c => c.category).filter(Boolean).filter(c => c !== 'Uncategorized'))];

              setFlashcards(result.cards);
              setCategories(uniqueCategories);
              setSelectedCategory('All'); // Reset category selection
              setCurrentCardIndex(0);
              setIsFlipped(false);
              setErrorMessage('');

              // Add to saved files
              const hasEncodingIssues = result.cards.some(card => (card.front && card.front.includes(' ')) || (card.back && card.back.includes(' ')));

              const newFile = {
                name: file.name,
                format: currentParseFormat,
                content: content, // Store original content
                cardCount: result.cards.length,
                categories: result.categories,
                date: new Date(),
                hasEncodingIssues: hasEncodingIssues, // Maybe less relevant now with cleaning
                isDefault: false
              };

              // Check if this filename already exists
              const existingIndex = savedFiles.findIndex(f => f.name === file.name);
              let newSavedFiles;
              let newActiveIndex;
              if (existingIndex >= 0) {
                // Replace the existing file
                newSavedFiles = [...savedFiles];
                newSavedFiles[existingIndex] = newFile;
                newActiveIndex = existingIndex;
              } else {
                // Add as a new file
                newSavedFiles = [...savedFiles, newFile];
                newActiveIndex = savedFiles.length; // Index will be the last one
              }
              setSavedFiles(newSavedFiles);
              setActiveFileIndex(newActiveIndex);

              // Show success notification
              const successCount = result.cards.length;
              setNotification(`Successfully imported ${successCount} flashcards from "${file.name}".`);

              // Clear notification after 5 seconds
              setTimeout(() => {
                setNotification('');
              }, 5000);
            }
          } catch (error) {
            console.error('Error processing file:', error);
            setErrorMessage(`Failed to process file: ${error.message}`);
            // Optionally revert to previous state or load sample data
            // loadSavedFile(activeFileIndex); // Revert to previously active file?
          } finally {
            setLoading(false);
            // Reset file input value
            if(fileInputRef.current) {
                fileInputRef.current.value = '';
            }
          }
        };

        reader.onerror = () => {
          setErrorMessage('Failed to read file.');
          setLoading(false);
           if(fileInputRef.current) {
                fileInputRef.current.value = '';
           }
        };

        reader.readAsText(file); // Consider adding encoding detection or selection later

      };

      const triggerFileInput = () => {
        fileInputRef.current.click();
      };

      const loadSavedFile = (index) => {
        if (index < 0 || index >= savedFiles.length) return;

        try {
          setLoading(true);
          setErrorMessage('');
          setNotification('');

          const file = savedFiles[index];
          const fileFormat = file.format; // Use the format stored with the file
          setImportFormat(fileFormat); // Update radio buttons

          let result;
          if (fileFormat === 'csv') {
            result = parseCsvData(file.content);
          } else if (fileFormat === 'json') {
            result = parseJsonData(file.content);
          } else { // markdown
            result = parseMarkdownData(file.content);
          }

          const uniqueCategories = ['All', ...new Set(result.cards.map(c => c.category).filter(Boolean).filter(c => c !== 'Uncategorized'))];

          setFlashcards(result.cards);
          setCategories(uniqueCategories);
          setSelectedCategory('All'); // Reset category
          setCurrentCardIndex(0);
          setIsFlipped(false);
          setActiveFileIndex(index); // Set this file as active

          setNotification(`Loaded "${file.name}" (${result.cards.length} cards)`);
          setTimeout(() => setNotification(''), 3000);

        } catch (error) {
          console.error('Error loading saved file:', error);
          setErrorMessage(`Error loading file "${savedFiles[index]?.name}": ${error.message}`);
          // Don't change the active file index on error
        } finally {
          setLoading(false);
        }
      };

      const deleteSavedFile = (index) => {
        // Don't allow deleting the default sample if it's the only one left maybe? Or just prevent it always.
        if (savedFiles[index].isDefault) {
          setNotification("Cannot delete the default sample data.");
          setTimeout(() => setNotification(''), 3000);
          return;
        }

        const fileToDelete = savedFiles[index];
        const newSavedFiles = savedFiles.filter((_, i) => i !== index);
        setSavedFiles(newSavedFiles);

        // If we deleted the active file
        if (index === activeFileIndex) {
          if (newSavedFiles.length > 0) {
            // Load the first available file (could be the sample)
            loadSavedFile(0);
          } else {
            // If no files left, reset to empty state
            setFlashcards([]);
            setCategories(['All']);
            setFilteredCards([]);
            setActiveFileIndex(-1);
            setErrorMessage("No flashcard sets loaded. Please import a file.");
          }
        } else if (index < activeFileIndex) {
          // If we deleted a file before the active one, adjust active index
          setActiveFileIndex(activeFileIndex - 1);
        }

        setNotification(`File "${fileToDelete.name}" deleted.`);
        setTimeout(() => setNotification(''), 3000);
      };

      const generateTemplateContent = () => {
        switch (importFormat) {
          case 'markdown':
            return `# Sample Flashcard Template (Markdown)

## Category 1 Name

### Subcategory 1.1 (Optional)
**Front:** Question 1 Front
**Back:** Answer 1 Back
Potentially multiple lines for the back.

**Front:** Question 2 Front
**Back:** Answer 2 Back

## Category 2 Name
**Front:** Question 3 Front (No Subcategory)
**Back:** Answer 3 Back
`;

          case 'csv':
            return `front,back,category,subcategory
"Question 1 Front","Answer 1 Back","Category 1 Name","Subcategory 1.1"
"Question 2 Front","Answer 2 Back with commas, maybe","Category 1 Name","Subcategory 1.1"
"Question 3 Front (No Subcategory)","Answer 3 Back","Category 2 Name",
"Question 4 Front","Answer 4 Back (No Category)","",
`;

          case 'json':
            return JSON.stringify([
              {
                "front": "Question 1 Front",
                "back": "Answer 1 Back",
                "category": "Category 1 Name",
                "subcategory": "Subcategory 1.1"
              },
              {
                "question": "Question 2 Front (using 'question')",
                "answer": "Answer 2 Back (using 'answer')",
                "category": "Category 1 Name",
                "subcategory": "Subcategory 1.1"
              },
              {
                "front": "Question 3 Front (No Subcategory)",
                "back": "Answer 3 Back",
                "category": "Category 2 Name"
              },
               {
                "front": "Question 4 Front",
                "back": "Answer 4 Back (No Category)"
              }
            ], null, 2); // null, 2 for pretty printing

          default:
            return 'Select a format (CSV, JSON, Markdown) to download the corresponding template.';
        }
      };

      const downloadTemplate = () => {
        const content = generateTemplateContent();
        if (content.startsWith('Select a format')) {
            setNotification(content, 3000); // Show message if format not selected (shouldn't happen with default)
            return;
        }
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); // Specify charset
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `flashcard-template.${importFormat === 'markdown' ? 'md' : importFormat}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const toggleSidebar = () => {
        setSidebarOpen(!sidebarOpen);
      };

      // Function to get format-specific icon
      const getFormatIcon = (format) => {
        switch (format) {
          case 'csv': return '📊'; // Bar Chart / Spreadsheet
          case 'json': return '{ }'; // Braces for JSON
          case 'markdown': return '📝'; // Memo / Markdown
          default: return '📄'; // Document
        }
      };

      // Format date for display
      const formatDate = (date) => {
        if (!(date instanceof Date)) {
            date = new Date(date); // Ensure it's a Date object
        }
        if (isNaN(date)) return 'Invalid Date'; // Check if date is valid
        try {
            return date.toLocaleDateString() + ' ' +
                   date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        } catch (e) {
             console.error("Error formatting date:", e);
             return 'Date Error';
        }
      };

      // Loading State UI
      if (loading && flashcards.length === 0) { // Only show full screen loading initially
        return (
          <div className="flex items-center justify-center h-screen bg-gray-100">
            <div className="text-center p-6 bg-white rounded-lg shadow-lg">
              <h2 className="text-xl font-bold mb-4 text-blue-600 animate-pulse">Loading...</h2>
              <p>Preparing your study session.</p>
            </div>
          </div>
        );
      }

      // Empty State / Initial Load UI
      if (flashcards.length === 0 && !loading) { // Show if loading finished but no cards
        return (
          <div className="flex items-center justify-center h-screen bg-gray-100">
            <div className="text-center p-6 bg-white rounded-lg shadow-lg max-w-md">
              <h2 className="text-2xl font-bold mb-4 text-blue-700">Virtual Flashcards</h2>
              <p className="mb-4 text-gray-600">Welcome! Import your flashcards to start studying.</p>

              {errorMessage && (
                <div className="mb-4 p-3 bg-red-100 text-red-700 rounded-lg text-sm">
                  {errorMessage}
                </div>
              )}
               {notification && (
                <div className="mb-4 p-3 bg-green-100 text-green-700 rounded-lg text-sm">
                  {notification}
                </div>
              )}

              <div className="mb-4 border-t pt-4">
                <label className="block text-sm font-medium mb-2 text-gray-700">Select Import Format:</label>
                <div className="flex justify-center gap-4 mb-4">
                  <label className="inline-flex items-center cursor-pointer">
                    <input type="radio" className="form-radio text-blue-600" name="empty-format" value="csv" checked={importFormat === 'csv'} onChange={() => setImportFormat('csv')} />
                    <span className="ml-2">CSV</span>
                  </label>
                  <label className="inline-flex items-center cursor-pointer">
                    <input type="radio" className="form-radio text-blue-600" name="empty-format" value="json" checked={importFormat === 'json'} onChange={() => setImportFormat('json')} />
                    <span className="ml-2">JSON</span>
                  </label>
                  <label className="inline-flex items-center cursor-pointer">
                    <input type="radio" className="form-radio text-blue-600" name="empty-format" value="markdown" checked={importFormat === 'markdown'} onChange={() => setImportFormat('markdown')} />
                    <span className="ml-2">Markdown</span>
                  </label>
                </div>
                 <button
                    onClick={triggerFileInput}
                    className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors mb-3"
                  >
                    Import Flashcards File
                  </button>
                  <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".csv, .json, .md, .txt" className="hidden" />

                 <button
                  onClick={downloadTemplate}
                  className="w-full px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors text-sm mb-3"
                 >
                    Download {importFormat.toUpperCase()} Template
                 </button>
                 <button
                    onClick={loadInitialData}
                    className="w-full px-4 py-1 bg-green-100 text-green-800 rounded hover:bg-green-200 transition-colors text-sm"
                  >
                    Load Sample Data
                  </button>
              </div>
                 <div className="mt-4 text-xs text-gray-500">
                     <a href="https://github.com/cpickett101/VirtualStudyApp" target="_blank" rel="noopener noreferrer" className="hover:text-blue-600">GitHub Repo</a> | Created by C. Pickett 2025
                 </div>
            </div>
          </div>
        );
      }


      // Main Application View (Sidebar + Content)
      return (
        <div className="flex h-screen bg-gray-100">
          {/* Sidebar */}
          <div className={`fixed md:static h-full z-30 w-64 bg-white shadow-lg sidebar-transition flex flex-col ${sidebarOpen ? 'sidebar-open' : 'sidebar-closed'}`}>
              {/* Sidebar Header */}
              <div className="p-4 border-b flex justify-between items-center">
                <h2 className="text-lg font-bold text-blue-800">Files</h2>
                 {/* Close button for mobile */}
                <button className="md:hidden text-gray-500 hover:text-gray-800" onClick={toggleSidebar}>✕</button>
              </div>

              {/* Saved Files List */}
              <div className="flex-grow overflow-y-auto p-2">
                {savedFiles.length === 0 && <p className="text-center text-gray-500 p-4 text-sm">No files loaded yet.</p>}
                {savedFiles.map((file, index) => (
                  <div
                    key={index}
                    className={`flex items-center justify-between p-2 mb-1 rounded cursor-pointer transition-all duration-150 ease-in-out border ${
                      index === activeFileIndex
                        ? 'bg-blue-100 border-blue-300 shadow-sm'
                        : 'bg-gray-50 hover:bg-gray-100 border-transparent hover:border-gray-300'
                    }`}
                    onClick={() => loadSavedFile(index)}
                    title={`Load ${file.name}\nFormat: ${file.format.toUpperCase()}\nCards: ${file.cardCount}\nDate: ${formatDate(file.date)}`}
                  >
                    <div className="flex items-center overflow-hidden">
                      <span className="mr-2 text-sm flex-shrink-0">{getFormatIcon(file.format)}</span>
                      <div className="overflow-hidden">
                        <p className={`font-medium truncate text-sm ${index === activeFileIndex ? 'text-blue-900' : 'text-gray-800'}`}>{file.name}</p>
                        <p className="text-xs text-gray-500">
                          {file.cardCount} cards • {file.format.toUpperCase()}
                        </p>
                         {file.isDefault && <span className="text-xs text-green-600">(Sample)</span>}
                      </div>
                    </div>
                    {!file.isDefault && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation(); // Prevent loadSavedFile from triggering
                          if (window.confirm(`Are you sure you want to delete "${file.name}"? This cannot be undone.`)) {
                                deleteSavedFile(index);
                          }
                        }}
                        className="text-red-400 hover:text-red-600 text-xs ml-1 px-1 py-0.5 rounded hover:bg-red-100 flex-shrink-0"
                        title="Delete file"
                      >
                        🗑️
                      </button>
                    )}
                  </div>
                ))}
              </div>

              {/* Sidebar Footer (Import Section) */}
              <div className="p-3 border-t bg-gray-50">
                <button
                  onClick={triggerFileInput}
                  className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors mb-2 text-sm"
                >
                  Import New File...
                </button>
                <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".csv,.json,.md,.txt" className="hidden"/>

                {/* Format Selection Area */}
                <div className="flex justify-around items-center space-x-1 mt-1 mb-2">
                   <span className="text-xs text-gray-600 mr-1">Format:</span>
                   <div className="flex-grow flex justify-center space-x-2">
                      <label className="inline-flex items-center text-xs cursor-pointer">
                        <input type="radio" className="form-radio h-3 w-3 text-blue-600" name="sidebar-format" value="csv" checked={importFormat === 'csv'} onChange={() => setImportFormat('csv')} />
                        <span className="ml-1">CSV</span>
                      </label>
                      <label className="inline-flex items-center text-xs cursor-pointer">
                        <input type="radio" className="form-radio h-3 w-3 text-blue-600" name="sidebar-format" value="json" checked={importFormat === 'json'} onChange={() => setImportFormat('json')} />
                        <span className="ml-1">JSON</span>
                      </label>
                      <label className="inline-flex items-center text-xs cursor-pointer">
                        <input type="radio" className="form-radio h-3 w-3 text-blue-600" name="sidebar-format" value="markdown" checked={importFormat === 'markdown'} onChange={() => setImportFormat('markdown')} />
                        <span className="ml-1">MD</span>
                      </label>
                    </div>
                </div>

                {/* Download Template Button */}
                <button
                  onClick={downloadTemplate}
                  className="w-full px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors text-xs"
                >
                  Download Template ({importFormat.toUpperCase()})
                </button>
              </div> {/* End of Sidebar Footer */}
          </div> {/* End of Sidebar div */}

          {/* Overlay for mobile when sidebar is open */}
           {sidebarOpen && <div className="fixed inset-0 bg-black bg-opacity-50 z-20 md:hidden" onClick={toggleSidebar}></div>}

          {/* Mobile sidebar toggle button (Hamburger) - Positioned relative to viewport */}
          {!sidebarOpen && (
             <button
              className="md:hidden fixed top-3 left-3 z-40 bg-blue-600 text-white p-2 rounded-md shadow-lg hover:bg-blue-700"
              onClick={toggleSidebar}
              aria-label="Open Menu"
             >
                ☰
             </button>
          )}


          {/* Main content Area */}
          {/* Adjust margin dynamically based on sidebar state for medium screens and up */}
          <div className={`flex-grow p-4 md:p-6 lg:p-8 overflow-y-auto main-content-transition ${sidebarOpen ? 'md:main-content-shifted' : 'md:main-content-unshifted'}`}>
             <div className="flex flex-col items-center min-h-full"> {/* Use min-h-full */}

                {/* Optional Header within main content (could be useful) */}
                 <div className="w-full max-w-4xl mb-4 flex justify-between items-center">
                    <h1 className="text-2xl font-bold text-gray-700">Study Session</h1>
                    {/* Maybe add some quick stats or controls here */}
                 </div>

                {/* Error & Notification Area */}
                <div className="w-full max-w-3xl mb-4 space-y-2">
                    {errorMessage && (
                      <div className="p-3 bg-red-100 text-red-700 rounded-lg text-sm flex justify-between items-center">
                         <span>{errorMessage}</span>
                         <button onClick={() => setErrorMessage('')} className="ml-2 text-red-500 hover:text-red-800">✕</button>
                      </div>
                    )}
                    {notification && (
                      <div className="p-3 bg-green-100 text-green-700 rounded-lg text-sm flex justify-between items-center">
                        <span>{notification}</span>
                        <button onClick={() => setNotification('')} className="ml-2 text-green-500 hover:text-green-800">✕</button>
                      </div>
                    )}
                </div>


                {/* Main Card and Controls Area */}
                <div className="w-full max-w-3xl">
                    {/* Controls (Category, Shuffle, Count) */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow flex flex-col md:flex-row justify-between items-center gap-3">
                      <div className="flex items-center w-full md:w-auto">
                        <label htmlFor="category-select" className="mr-2 text-sm font-medium text-gray-700 flex-shrink-0">Category:</label>
                        <select
                          id="category-select"
                          value={selectedCategory}
                          onChange={handleCategoryChange}
                          className="flex-grow p-2 border border-gray-300 rounded bg-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        >
                          {categories.map((category, index) => (
                            <option key={index} value={category}>{category}</option>
                          ))}
                        </select>
                      </div>
                      <div className="flex items-center space-x-2 w-full md:w-auto justify-end">
                        <button
                          onClick={shuffleCards}
                          className="px-3 py-1.5 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors text-sm shadow"
                          title="Shuffle cards in current category"
                          disabled={filteredCards.length < 2} // Disable if less than 2 cards
                        >
                          Shuffle
                        </button>
                        <span className="px-3 py-1.5 bg-gray-200 text-gray-700 rounded text-sm font-medium shadow-sm">
                          {filteredCards.length > 0 ? `${currentCardIndex + 1} / ${filteredCards.length}` : '0 / 0'}
                        </span>
                      </div>
                    </div>


                    {/* Flashcard Display */}
                    {filteredCards.length > 0 ? (
                      <div className="relative"> {/* Container for card and context */}
                          <div
                            className="w-full h-80 md:h-96 perspective-1000 mb-4 cursor-pointer group" // Added group for potential hover effects
                            onClick={flipCard}
                            role="button"
                            tabIndex="0" // Make it focusable
                            onKeyPress={(e) => { if (e.key === ' ' || e.key === 'Enter') flipCard(); }} // Flip on space/enter
                            aria-live="polite" // Announce changes
                            aria-label={`Flashcard ${currentCardIndex + 1} of ${filteredCards.length}. Currently showing ${isFlipped ? 'back' : 'front'}. Click or press space/enter to flip.`}
                          >
                            <div className={`relative w-full h-full transition-transform duration-500 transform-style-preserve-3d ${isFlipped ? 'rotate-y-180' : ''}`}>
                              {/* Card Front */}
                              <div className="card-front bg-white p-6 rounded-xl shadow-lg flex flex-col border border-gray-200">
                                 {/* Optional Subcategory/Context on Front */}
                                <div className="absolute top-3 left-3 text-xs text-gray-400">
                                  {filteredCards[currentCardIndex].category !== 'All' && filteredCards[currentCardIndex].category !== 'Uncategorized' && (
                                      <span className="bg-gray-100 px-1.5 py-0.5 rounded mr-1">{filteredCards[currentCardIndex].category}</span>
                                  )}
                                   {filteredCards[currentCardIndex].subcategory && (
                                    <span className="bg-blue-100 text-blue-800 px-1.5 py-0.5 rounded">{filteredCards[currentCardIndex].subcategory}</span>
                                  )}
                                </div>

                                <div className="flex-grow flex items-center justify-center pt-6">
                                  <div className="text-xl md:text-2xl font-semibold text-center text-gray-800 break-words">
                                    {filteredCards[currentCardIndex].front}
                                  </div>
                                </div>
                                <div className="text-center text-gray-400 text-xs mt-4 group-hover:text-blue-500">Click to flip</div>
                              </div>

                              {/* Card Back */}
                              <div className="card-back bg-blue-50 p-6 rounded-xl shadow-lg flex flex-col border border-blue-200">
                                <div className="flex-grow flex items-center justify-center overflow-y-auto">
                                   {/* Render back content, handling newlines */}
                                   <div className="text-base md:text-lg text-gray-900">
                                    {filteredCards[currentCardIndex].back.split('\n').map((line, index, arr) => (
                                      <p key={index} className={index === arr.length - 1 ? '' : 'mb-2'}>{line || '\u00A0'}</p> // Render empty lines as non-breaking space
                                    ))}
                                   </div>
                                </div>
                                <div className="text-center text-gray-500 text-xs mt-4 group-hover:text-blue-600">Click to flip back</div>
                              </div>
                            </div>
                          </div>
                           {/* Context Display Below Card */}
                          {filteredCards[currentCardIndex]?.subcategory && (
                               <p className="text-center text-xs text-gray-500 italic mb-4">
                                  Subcategory: {filteredCards[currentCardIndex].subcategory}
                               </p>
                           )}
                      </div> // End card container
                    ) : (
                      <div className="text-center text-gray-500 mt-10 p-6 bg-white rounded-lg shadow">
                          No cards match the selected category "{selectedCategory}".
                      </div>
                    )}

                    {/* Navigation Buttons */}
                    {filteredCards.length > 0 && (
                      <div className="flex justify-center space-x-4 mt-2">
                        <button
                          onClick={prevCard}
                          disabled={currentCardIndex === 0}
                          className={`px-5 py-2 rounded font-medium text-sm shadow transition-colors duration-150 ${currentCardIndex === 0 ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-white text-blue-700 border border-blue-300 hover:bg-blue-50'}`}
                          aria-label="Previous Card"
                        >
                          Previous
                        </button>
                        <button
                          onClick={nextCard}
                          disabled={currentCardIndex === filteredCards.length - 1}
                          className={`px-5 py-2 rounded font-medium text-sm shadow transition-colors duration-150 ${currentCardIndex === filteredCards.length - 1 ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700'}`}
                           aria-label="Next Card"
                        >
                          Next
                        </button>
                      </div>
                    )}
                </div> {/* End Main Card and Controls Area */}

                 {/* Footer Links */}
                 <div className="w-full max-w-3xl mt-8 pt-4 border-t border-gray-200 text-center text-xs text-gray-500">
                    <a href="https://github.com/cpickett101/VirtualStudyApp" target="_blank" rel="noopener noreferrer" className="hover:text-blue-600">GitHub Repository</a>
                    <span className="mx-2">|</span>
                    Created by <a href="https://www.linkedin.com/in/christopher-p-a4908979/" target="_blank" rel="noopener noreferrer" className="hover:text-blue-600">Christopher Pickett</a> - 2025
                 </div>

             </div> {/* End of flex flex-col items-center */}
          </div> {/* End of Main content div */}
        </div> // End of flex h-screen container
      );
    }; // End of App component

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
