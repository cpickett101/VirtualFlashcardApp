<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual Flashcard App</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    .perspective-1000 {
      perspective: 1000px;
    }
    .transform-style-preserve-3d {
      transform-style: preserve-3d;
    }
    .backface-hidden {
      backface-visibility: hidden;
    }
    .rotate-y-180 {
      transform: rotateY(180deg);
    }
    /* Fix for card flip */
    .card-front {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      z-index: 1; /* Ensure front is initially visible */
    }
    .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      transform: rotateY(180deg);
    }
    /* Custom scroll styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    /* Smooth transitions */
    .transition-transform {
      transition: transform 0.6s; /* Slightly slower flip */
    }
    /* Sidebar transition */
    .sidebar-transition {
      transition: transform 0.3s ease-in-out;
    }
    .sidebar-open {
      transform: translateX(0);
    }
    .sidebar-closed {
      transform: translateX(-100%);
    }
    /* Keep sidebar visible on medium screens and up when closed */
    @media (min-width: 768px) {
      .sidebar-closed {
        transform: translateX(0); /* Sidebar stays visible */
      }
      /* Adjust main content margin based on sidebar visibility */
      .main-content-shifted {
        margin-left: 16rem; /* 64 * 0.25rem = 16rem */
      }
      .main-content-unshifted {
        margin-left: 0;
      }
    }
    .main-content-transition {
      transition: margin-left 0.3s ease-in-out;
    }

    /* <<< Added CSS Rule >>> */
    .preserve-whitespace {
      white-space: pre-wrap; /* Preserve whitespace and wrap lines */
      word-wrap: break-word; /* Ensure long words without spaces also wrap */
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen overflow-x-hidden">
  <div id="root"></div>

  <script type="text/babel">
    // Sample data - this would be loaded from a file in a real application
    const sampleData = `front,back,category,subcategory
"What is Data Manipulation in the context of GIS?","Data manipulation includes the theories and techniques for managing the entire data lifecycle, from data collection to data format conversion,
from data storage to data sharing and retrieval,
to data provenance, data quality control, and data curation for long-term data archival and preservation.","Core Concepts","What is Data Manipulation?"
"What is Georeferencing in GIS?","Georeferencing is a crucial process that aligns spatial data, such as satellite images or scanned maps, with real-world coordinates, placing them in their correct spatial location within a map coordinate system.","Core Concepts","Georeferencing"
"What is an Affine Transformation?","Affine Transformation includes:
- scaling
- rotation
- translation
- skewing.

It preserves straight lines and is commonly used for georeferencing.","Core Concepts","Transformation Methods"
"What is a Polynomial Transformation?","Polynomial transformations (first-order, second-order, etc.) adjust the shape of the raster more flexibly. They are useful when the relationship between control points is nonlinear.","Core Concepts","Transformation Methods"`;

    const App = () => {
      const [flashcards, setFlashcards] = React.useState([]);
      const [currentCardIndex, setCurrentCardIndex] = React.useState(0);
      const [isFlipped, setIsFlipped] = React.useState(false);
      const [categories, setCategories] = React.useState([]);
      const [selectedCategory, setSelectedCategory] = React.useState('All');
      const [filteredCards, setFilteredCards] = React.useState([]);
      const [loading, setLoading] = React.useState(true);
      const [importFormat, setImportFormat] = React.useState('csv');
      const [errorMessage, setErrorMessage] = React.useState('');
      const [notification, setNotification] = React.useState('');
      // Sidebar state default to closed on mobile, open on desktop
      const [sidebarOpen, setSidebarOpen] = React.useState(window.innerWidth >= 768);

      // New state for saved files
      const [savedFiles, setSavedFiles] = React.useState([]);
      const [activeFileIndex, setActiveFileIndex] = React.useState(-1);

      const fileInputRef = React.useRef(null);

      // Function to clean text and fix encoding issues
// Fixed version:
const cleanText = (text) => {
  if (typeof text !== 'string') return ''; // Ensure input is a string

  // Replace common problematic characters and encoding issues
  return text
    // Remove this line or fix it to target only specific non-standard spaces
    // .replace(/ /g, '') // This was removing all spaces!
    .replace(/[\u2018\u2019]/g, "'") // Smart single quotes
    .replace(/[\u201C\u201D]/g, '"') // Smart double quotes
    // ...other replacements...
    .trim();
};

      const parseMarkdownData = (text) => {
        // Clean the text before parsing
        text = cleanText(text);

        const frontBackPairs = [];
        let allCategories = new Set(); // Use Set for uniqueness
        let currentCategory = 'Uncategorized';
        let currentSubcategory = '';

        // Extract categories and subcategories
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
          // Use original line without trim here to preserve leading spaces if needed by format,
          // but trim for comparisons/matches
          const line = lines[i];
          const trimmedLine = line.trim();

          // Check for main category
          const categoryMatch = trimmedLine.match(/^## (.+)$/);
          if (categoryMatch) {
            currentCategory = categoryMatch[1].trim();
            allCategories.add(currentCategory);
            currentSubcategory = ''; // Reset subcategory when main category changes
            continue;
          }

          // Check for subcategory
          const subcategoryMatch = trimmedLine.match(/^### (.+)$/);
          if (subcategoryMatch) {
            currentSubcategory = subcategoryMatch[1].trim();
            continue;
          }

          // Check for flashcard content
          if (trimmedLine.toLowerCase().startsWith('**front:**')) {
            // Get content after marker, preserve original spacing from the line
            let frontContent = line.substring(line.toLowerCase().indexOf('**front:**') + '**Front:**'.length).trimStart(); // Trim only leading space after marker

            // Look for the corresponding Back content
            let backContentLines = [];
            let j = i + 1;
            let backMarkerFound = false;
            while (j < lines.length) {
                const nextLine = lines[j];
                const trimmedNextLine = nextLine.trim();

                if (trimmedNextLine.toLowerCase().startsWith('**back:**')) {
                    // Found the back marker, take content after it from this line
                    backContentLines.push(nextLine.substring(nextLine.toLowerCase().indexOf('**back:**') + '**Back:**'.length).trimStart());
                    backMarkerFound = true;
                } else if (backMarkerFound) {
                    // If back marker was found, collect subsequent lines until next card/category or empty line
                     if (trimmedNextLine === '' || trimmedNextLine.startsWith('## ') || trimmedNextLine.startsWith('### ') || trimmedNextLine.toLowerCase().startsWith('**front:**')) {
                        break; // Stop collecting for this back
                     }
                     backContentLines.push(nextLine); // Add the whole line to preserve indentation
                } else if (trimmedNextLine.startsWith('## ') || trimmedNextLine.startsWith('### ') || trimmedNextLine.toLowerCase().startsWith('**front:**')) {
                     // If we hit another marker before finding **Back:**, this front has no back
                     break;
                }
                j++;
            }

            if (backMarkerFound) {
              frontBackPairs.push({
                front: cleanText(frontContent), // Clean final content
                back: cleanText(backContentLines.join('\n')), // Join lines and clean final
                category: currentCategory,
                subcategory: currentSubcategory
              });
              i = j - 1; // Move index past the processed lines
            }
          }
        }

        return { cards: frontBackPairs, categories: Array.from(allCategories) };
      };

      const parseCsvData = (text) => {
        // Clean the text before parsing - Be careful not to over-clean CSV structure
        // text = cleanText(text); // Maybe only clean *after* parsing cells

        const result = Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          transformHeader: header => header.trim().toLowerCase(), // Normalize headers
        });

        if (result.errors.length > 0) {
          console.warn('CSV Parsing warnings:', result.errors);
          // Allow proceeding even with errors if data exists
        }

        if (!result.data || result.data.length === 0) {
             throw new Error('No data found in CSV file.');
        }

        if (!result.meta.fields.includes('front') || !result.meta.fields.includes('back')) {
          throw new Error('CSV must contain at least "front" and "back" columns (case-insensitive)');
        }

        const frontBackPairs = result.data.map(row => ({
          front: cleanText(row.front), // Clean cell content
          back: cleanText(row.back),   // Clean cell content
          category: cleanText(row.category) || 'Uncategorized',
          subcategory: cleanText(row.subcategory) || ''
        }));

        const allCategories = [...new Set(frontBackPairs.map(card => card.category))].filter(Boolean).filter(cat => cat !== 'Uncategorized');

        return { cards: frontBackPairs, categories: allCategories };
      };

      const parseJsonData = (text) => {
        try {
          // Don't clean JSON structure itself, only the values later
          // text = cleanText(text);

          let data;
          try {
             data = JSON.parse(text);
          } catch (parseError) {
              // Try cleaning BOM / leading-trailing whitespace before failing
              try {
                  data = JSON.parse(cleanText(text));
              } catch (innerError) {
                   throw new Error('Invalid JSON format: ' + parseError.message);
              }
          }


          if (!Array.isArray(data)) {
            throw new Error('JSON data must be an array of flashcard objects');
          }

          const frontBackPairs = data.map(item => ({
            front: cleanText(item.front || item.question || ''), // Clean value
            back: cleanText(item.back || item.answer || ''),   // Clean value
            category: cleanText(item.category) || 'Uncategorized',
            subcategory: cleanText(item.subcategory) || ''
          }));

          if (frontBackPairs.some(card => !card.front || !card.back)) {
            console.warn('Some JSON objects missing front/back or question/answer fields');
            // Allow proceeding, filter out invalid cards later if needed
          }
          const validPairs = frontBackPairs.filter(card => card.front && card.back);

          if (validPairs.length === 0) {
              throw new Error('No valid flashcards with both front and back found in JSON data.');
          }

          const allCategories = [...new Set(validPairs.map(card => card.category))].filter(Boolean).filter(cat => cat !== 'Uncategorized');

          return { cards: validPairs, categories: allCategories };
        } catch (error) {
           // Catch errors from JSON.parse or validation
           throw new Error('Error processing JSON: ' + error.message);
        }
      };

      React.useEffect(() => {
        loadInitialData();
         // Add resize listener to handle sidebar state changes
        const handleResize = () => {
            if (window.innerWidth >= 768) {
                 // On desktop, only force open if it wasn't manually closed perhaps?
                 // For simplicity, let's keep it always open on >= md for now.
                 // Could add another state variable `isSidebarManuallyClosed` if needed.
                setSidebarOpen(true);
            } else {
                // On mobile, respect the current state unless resizing makes it desktop
                // setSidebarOpen(false); // Let's keep the toggle state persistent on mobile resize
            }
        };
        window.addEventListener('resize', handleResize);
        // Initial check
        handleResize();
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      const loadInitialData = () => {
        try {
          setLoading(true);
          const { cards, categories } = parseCsvData(sampleData);

          setCategories(['All', ...categories]);
          setFlashcards(cards);
          setFilteredCards(cards); // Set filtered cards initially
          setCurrentCardIndex(0); // Reset index
          setIsFlipped(false); // Reset flip state
          setErrorMessage('');

          // Add sample data to saved files
          const sampleFile = {
              name: 'Sample Data (CSV)',
              format: 'csv',
              content: sampleData,
              cardCount: cards.length,
              categories: categories,
              date: new Date(),
              isDefault: true
          };
          setSavedFiles([sampleFile]);
          setActiveFileIndex(0); // Set the sample data as active
          setImportFormat('csv'); // Match the format of the loaded sample

        } catch (error) {
          console.error('Error parsing flashcard data:', error);
          setErrorMessage('Could not load initial data: ' + error.message);
          setFlashcards([]);
          setFilteredCards([]);
          setSavedFiles([]); // Clear saved files on error loading initial
          setActiveFileIndex(-1);
        } finally {
          setLoading(false);
        }
      };

      React.useEffect(() => {
        let newFilteredCards;
        if (selectedCategory === 'All') {
          newFilteredCards = flashcards;
        } else {
          newFilteredCards = flashcards.filter(card => card.category === selectedCategory);
        }
        setFilteredCards(newFilteredCards);
        setCurrentCardIndex(0);
        setIsFlipped(false);
      }, [selectedCategory, flashcards]);

      const flipCard = () => {
        setIsFlipped(!isFlipped);
      };

      const nextCard = () => {
        if (currentCardIndex < filteredCards.length - 1) {
          setCurrentCardIndex(currentCardIndex + 1);
          setIsFlipped(false);
        } else {
            // Optional: Loop back to start
            setCurrentCardIndex(0);
            setIsFlipped(false);
        }
      };

      const prevCard = () => {
        if (currentCardIndex > 0) {
          setCurrentCardIndex(currentCardIndex - 1);
          setIsFlipped(false);
        } else {
             // Optional: Loop back to end
             if (filteredCards.length > 0) {
               setCurrentCardIndex(filteredCards.length - 1);
               setIsFlipped(false);
             }
        }
      };

      const shuffleCards = () => {
        const currentCard = filteredCards[currentCardIndex];
        const otherCards = filteredCards.filter((_, index) => index !== currentCardIndex);
        const shuffledOthers = _.shuffle(otherCards);
        // Keep current card at the start? Or fully shuffle? Let's fully shuffle.
        const shuffled = _.shuffle([...filteredCards]);
        setFilteredCards(shuffled);
        setCurrentCardIndex(0); // Go to the start of the shuffled deck
        setIsFlipped(false);
        setNotification('Cards shuffled!');
        setTimeout(() => setNotification(''), 2000);
      };

      const handleCategoryChange = (e) => {
        setSelectedCategory(e.target.value);
      };

      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        setLoading(true);
        setErrorMessage('');
        setNotification('');

        // Determine format from extension if not explicitly set (or use selected format)
        const fileExtension = file.name.split('.').pop().toLowerCase();
        let currentParseFormat = importFormat; // Default to selected format

        // Attempt to guess format from extension
        if (fileExtension === 'csv') {
            currentParseFormat = 'csv';
        } else if (fileExtension === 'json') {
            currentParseFormat = 'json';
        } else if (fileExtension === 'md' || fileExtension === 'txt') {
            currentParseFormat = 'markdown';
        }
        // Update the radio button selection to match detected/used format
        setImportFormat(currentParseFormat);


        const reader = new FileReader();

        reader.onload = (event) => {
          try {
            const content = event.target.result;
            let result;

            if (currentParseFormat === 'csv') {
              result = parseCsvData(content);
            } else if (currentParseFormat === 'json') {
              result = parseJsonData(content);
            } else { // markdown
              result = parseMarkdownData(content);
            }

            if (!result || result.cards.length === 0) {
              setErrorMessage('No valid flashcards found in file.');
            } else {
              const uniqueCategories = ['All', ...new Set(result.cards.map(c => c.category).filter(Boolean).filter(c => c !== 'Uncategorized'))];

              setFlashcards(result.cards);
              setCategories(uniqueCategories);
              setSelectedCategory('All'); // Reset category selection
              setCurrentCardIndex(0);
              setIsFlipped(false);
              setErrorMessage('');

              // Add to saved files
              const newFile = {
                name: file.name,
                format: currentParseFormat,
                content: content, // Store original content
                cardCount: result.cards.length,
                categories: result.categories,
                date: new Date(),
                isDefault: false
              };

              // Check if this filename already exists
              const existingIndex = savedFiles.findIndex(f => f.name === file.name);
              let newSavedFiles;
              let newActiveIndex;
              if (existingIndex >= 0) {
                // Replace the existing file
                newSavedFiles = [...savedFiles];
                newSavedFiles[existingIndex] = newFile;
                newActiveIndex = existingIndex;
              } else {
                // Add as a new file
                newSavedFiles = [...savedFiles, newFile];
                newActiveIndex = savedFiles.length; // Index will be the last one
              }
              setSavedFiles(newSavedFiles);
              setActiveFileIndex(newActiveIndex);

              // Show success notification
              const successCount = result.cards.length;
              setNotification(`Successfully imported ${successCount} flashcards from "${file.name}".`);

              // Clear notification after 5 seconds
              setTimeout(() => {
                setNotification('');
              }, 5000);
            }
          } catch (error) {
            console.error('Error processing file:', error);
            setErrorMessage(`Failed to process file "${file.name}": ${error.message}`);
          } finally {
            setLoading(false);
            // Reset file input value
            if(fileInputRef.current) {
                fileInputRef.current.value = '';
            }
          }
        };

        reader.onerror = (error) => {
          setErrorMessage(`Failed to read file: ${error.message || 'Unknown read error'}`);
          setLoading(false);
           if(fileInputRef.current) {
                fileInputRef.current.value = '';
           }
        };

        reader.readAsText(file); // Consider adding encoding detection or selection later

      };

      const triggerFileInput = () => {
        setErrorMessage(''); // Clear errors before opening dialog
        fileInputRef.current.click();
      };

      const loadSavedFile = (index) => {
        if (index < 0 || index >= savedFiles.length || index === activeFileIndex) return; // Don't reload if already active

        try {
          setLoading(true);
          setErrorMessage('');
          setNotification('');

          const file = savedFiles[index];
          const fileFormat = file.format; // Use the format stored with the file
          setImportFormat(fileFormat); // Update radio buttons

          let result;
          if (fileFormat === 'csv') {
            result = parseCsvData(file.content);
          } else if (fileFormat === 'json') {
            result = parseJsonData(file.content);
          } else { // markdown
            result = parseMarkdownData(file.content);
          }

          const uniqueCategories = ['All', ...new Set(result.cards.map(c => c.category).filter(Boolean).filter(c => c !== 'Uncategorized'))];

          setFlashcards(result.cards);
          setCategories(uniqueCategories);
          setSelectedCategory('All'); // Reset category
          setCurrentCardIndex(0);
          setIsFlipped(false);
          setActiveFileIndex(index); // Set this file as active

          setNotification(`Loaded "${file.name}" (${result.cards.length} cards)`);
          setTimeout(() => setNotification(''), 3000);

        } catch (error) {
          console.error('Error loading saved file:', error);
          setErrorMessage(`Error loading file "${savedFiles[index]?.name}": ${error.message}`);
          // Don't change the active file index on error
        } finally {
          setLoading(false);
        }
      };

      const deleteSavedFile = (index) => {
        if (index < 0 || index >= savedFiles.length) return;

        if (savedFiles[index].isDefault) {
          setNotification("Cannot delete the default sample data.");
          setTimeout(() => setNotification(''), 3000);
          return;
        }

        const fileToDelete = savedFiles[index];
        const newSavedFiles = savedFiles.filter((_, i) => i !== index);


        // Determine the next active index *before* setting state
        let nextActiveIndex = activeFileIndex;
        if (index === activeFileIndex) {
            // If we deleted the active file
            if (newSavedFiles.length > 0) {
                // Make the first file active (could be index 0 or adjusted index)
                nextActiveIndex = 0; // Simplest approach: always go to first
            } else {
                nextActiveIndex = -1; // No files left
            }
        } else if (index < activeFileIndex) {
            // If we deleted a file *before* the active one, decrement active index
            nextActiveIndex = activeFileIndex - 1;
        }
         // If we deleted *after* the active one, the index remains correct

        setSavedFiles(newSavedFiles);
        setActiveFileIndex(nextActiveIndex); // Update active index state

        // Load the new active file if one exists and was changed
        if (nextActiveIndex !== -1 && index === activeFileIndex) {
            // Need to load the content for the *new* active index
             loadSavedFile(nextActiveIndex); // Reload content for the new index 0
        } else if (nextActiveIndex === -1) {
            // If no files left, clear the view
             setFlashcards([]);
             setCategories(['All']);
             setFilteredCards([]);
             setErrorMessage("No flashcard sets loaded. Please import a file.");
        }


        setNotification(`File "${fileToDelete.name}" deleted.`);
        setTimeout(() => setNotification(''), 3000);
      };

      const generateTemplateContent = () => {
        switch (importFormat) {
          case 'markdown':
            return `# Sample Flashcard Template (Markdown)

## Category 1 Name

### Subcategory 1.1 (Optional)
**Front:** Question 1 Front
**Back:** Answer 1 Back
Potentially multiple lines for the back.

**Front:** Question 2 Front
**Back:** Answer 2 Back

## Category 2 Name
**Front:** Question 3 Front (No Subcategory)
**Back:** Answer 3 Back
`;

          case 'csv':
            return `front,back,category,subcategory
"Question 1 Front","Answer 1 Back","Category 1 Name","Subcategory 1.1"
"Question 2 Front","Answer 2 Back with commas,
and newlines preserved.","Category 1 Name","Subcategory 1.1"
"Question 3 Front (No Subcategory)","Answer 3 Back","Category 2 Name",
"Question 4 Front","Answer 4 Back (No Category)","",
`;

          case 'json':
            return JSON.stringify([
              {
                "front": "Question 1 Front",
                "back": "Answer 1 Back",
                "category": "Category 1 Name",
                "subcategory": "Subcategory 1.1"
              },
              {
                "question": "Question 2 Front (using 'question')",
                "answer": "Answer 2 Back (using 'answer')\nWith newlines preserved.",
                "category": "Category 1 Name",
                "subcategory": "Subcategory 1.1"
              },
              {
                "front": "Question 3 Front (No Subcategory)",
                "back": "Answer 3 Back",
                "category": "Category 2 Name"
              },
               {
                "front": "Question 4 Front",
                "back": "Answer 4 Back (No Category)"
              }
            ], null, 2); // null, 2 for pretty printing

          default:
            return 'Select a format (CSV, JSON, Markdown) to download the corresponding template.';
        }
      };

      const downloadTemplate = () => {
        const content = generateTemplateContent();
        if (content.startsWith('Select a format')) {
            setNotification(content, 3000); // Show message if format not selected (shouldn't happen with default)
            return;
        }
        // Add BOM for CSV to help Excel with UTF-8
        const bom = importFormat === 'csv' ? "\uFEFF" : "";
        const blob = new Blob([bom + content], { type: 'text/plain;charset=utf-8' }); // Specify charset
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `flashcard-template.${importFormat === 'markdown' ? 'md' : importFormat}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const toggleSidebar = () => {
        setSidebarOpen(!sidebarOpen);
      };

      // Function to get format-specific icon
      const getFormatIcon = (format) => {
        switch (format) {
          case 'csv': return '📊'; // Bar Chart / Spreadsheet
          case 'json': return '{ }'; // Braces for JSON
          case 'markdown': return '📝'; // Memo / Markdown
          default: return '📄'; // Document
        }
      };

      // Format date for display
      const formatDate = (date) => {
        if (!(date instanceof Date)) {
            date = new Date(date); // Ensure it's a Date object
        }
        if (isNaN(date)) return 'Invalid Date'; // Check if date is valid
        try {
            return date.toLocaleDateString() + ' ' +
                   date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        } catch (e) {
             console.error("Error formatting date:", e);
             return 'Date Error';
        }
      };

      // Loading State UI
      if (loading && savedFiles.length === 0) { // Only show full screen loading on very first load
        return (
          <div className="flex items-center justify-center h-screen bg-gray-100">
            <div className="text-center p-6 bg-white rounded-lg shadow-lg">
              <h2 className="text-xl font-bold mb-4 text-blue-600 animate-pulse">Loading...</h2>
              <p>Preparing your study session.</p>
            </div>
          </div>
        );
      }

      // Empty State / Initial Load UI (Only if no saved files exist after loading)
      if (savedFiles.length === 0 && !loading) { // Show if loading finished but no files ever loaded
        return (
          <div className="flex items-center justify-center h-screen bg-gray-100">
            <div className="text-center p-6 bg-white rounded-lg shadow-lg max-w-md">
              <h2 className="text-2xl font-bold mb-4 text-blue-700">Virtual Flashcards</h2>
              <p className="mb-4 text-gray-600">Welcome! Import your flashcards to start studying.</p>

              {errorMessage && (
                <div className="mb-4 p-3 bg-red-100 text-red-700 rounded-lg text-sm">
                  {errorMessage}
                </div>
              )}
               {notification && (
                <div className="mb-4 p-3 bg-green-100 text-green-700 rounded-lg text-sm">
                  {notification}
                </div>
              )}

              <div className="mb-4 border-t pt-4">
                <label className="block text-sm font-medium mb-2 text-gray-700">Select Import Format:</label>
                <div className="flex justify-center gap-4 mb-4">
                  <label className="inline-flex items-center cursor-pointer">
                    <input type="radio" className="form-radio text-blue-600" name="empty-format" value="csv" checked={importFormat === 'csv'} onChange={() => setImportFormat('csv')} />
                    <span className="ml-2">CSV</span>
                  </label>
                  <label className="inline-flex items-center cursor-pointer">
                    <input type="radio" className="form-radio text-blue-600" name="empty-format" value="json" checked={importFormat === 'json'} onChange={() => setImportFormat('json')} />
                    <span className="ml-2">JSON</span>
                  </label>
                  <label className="inline-flex items-center cursor-pointer">
                    <input type="radio" className="form-radio text-blue-600" name="empty-format" value="markdown" checked={importFormat === 'markdown'} onChange={() => setImportFormat('markdown')} />
                    <span className="ml-2">Markdown</span>
                  </label>
                </div>
                 <button
                    onClick={triggerFileInput}
                    className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors mb-3"
                  >
                    Import Flashcards File
                  </button>
                  <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".csv, .json, .md, .txt" className="hidden" />

                 <button
                  onClick={downloadTemplate}
                  className="w-full px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors text-sm mb-3"
                 >
                    Download {importFormat.toUpperCase()} Template
                 </button>
                 <button
                    onClick={loadInitialData}
                    className="w-full px-4 py-1 bg-green-100 text-green-800 rounded hover:bg-green-200 transition-colors text-sm"
                  >
                    Load Sample Data
                  </button>
              </div>
                 <div className="mt-4 text-xs text-gray-500">
                     <a href="https://github.com/cpickett101/VirtualFlashcardApp" target="_blank" rel="noopener noreferrer" className="hover:text-blue-600">GitHub Repo</a> | Created by C. Pickett 2025
                 </div>
            </div>
          </div>
        );
      }


      // Main Application View (Sidebar + Content)
      return (
        <div className="flex h-screen bg-gray-100">
          {/* Sidebar */}
          <div className={`fixed md:static h-full z-30 w-64 bg-white shadow-lg sidebar-transition flex flex-col ${sidebarOpen ? 'sidebar-open' : 'sidebar-closed'}`}>
              {/* Sidebar Header */}
              <div className="p-4 border-b flex justify-between items-center flex-shrink-0">
                <h2 className="text-lg font-bold text-blue-800">Files</h2>
                 {/* Close button for mobile */}
                <button className="md:hidden text-gray-500 hover:text-gray-800" onClick={toggleSidebar}>✕</button>
              </div>

              {/* Saved Files List */}
              <div className="flex-grow overflow-y-auto p-2">
                {savedFiles.length === 0 && !loading && <p className="text-center text-gray-500 p-4 text-sm">No files loaded yet.</p>}
                {loading && savedFiles.length > 0 && <p className="text-center text-gray-500 p-4 text-sm animate-pulse">Loading...</p> }
                {savedFiles.map((file, index) => (
                  <div
                    key={index + '-' + file.name} // Add name to key for better stability if list order changes
                    className={`flex items-center justify-between p-2 mb-1 rounded cursor-pointer transition-all duration-150 ease-in-out border ${
                      index === activeFileIndex
                        ? 'bg-blue-100 border-blue-300 shadow-sm'
                        : 'bg-gray-50 hover:bg-gray-100 border-transparent hover:border-gray-300'
                    }`}
                    onClick={() => loadSavedFile(index)}
                    title={`Load ${file.name}\nFormat: ${file.format.toUpperCase()}\nCards: ${file.cardCount}\nDate: ${formatDate(file.date)}`}
                  >
                    <div className="flex items-center overflow-hidden">
                      <span className="mr-2 text-sm flex-shrink-0">{getFormatIcon(file.format)}</span>
                      <div className="overflow-hidden">
                        <p className={`font-medium truncate text-sm ${index === activeFileIndex ? 'text-blue-900' : 'text-gray-800'}`}>{file.name}</p>
                        <p className="text-xs text-gray-500">
                          {file.cardCount} cards • {file.format.toUpperCase()}
                        </p>
                         {file.isDefault && <span className="text-xs text-green-600">(Sample)</span>}
                      </div>
                    </div>
                    {!file.isDefault && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation(); // Prevent loadSavedFile from triggering
                          if (window.confirm(`Are you sure you want to delete "${file.name}"? This cannot be undone.`)) {
                                deleteSavedFile(index);
                          }
                        }}
                        className="text-red-400 hover:text-red-600 text-xs ml-1 px-1 py-0.5 rounded hover:bg-red-100 flex-shrink-0"
                        title="Delete file"
                      >
                        🗑️
                      </button>
                    )}
                  </div>
                ))}
              </div>

              {/* Sidebar Footer (Import Section) */}
              <div className="p-3 border-t bg-gray-50 flex-shrink-0">
                <button
                  onClick={triggerFileInput}
                  className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors mb-2 text-sm"
                >
                  Import New File...
                </button>
                <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".csv,.json,.md,.txt" className="hidden"/>

                {/* Format Selection Area */}
                <div className="flex justify-around items-center space-x-1 mt-1 mb-2">
                   <span className="text-xs text-gray-600 mr-1">Format:</span>
                   <div className="flex-grow flex justify-center space-x-2">
                      <label className="inline-flex items-center text-xs cursor-pointer">
                        <input type="radio" className="form-radio h-3 w-3 text-blue-600" name="sidebar-format" value="csv" checked={importFormat === 'csv'} onChange={() => setImportFormat('csv')} />
                        <span className="ml-1">CSV</span>
                      </label>
                      <label className="inline-flex items-center text-xs cursor-pointer">
                        <input type="radio" className="form-radio h-3 w-3 text-blue-600" name="sidebar-format" value="json" checked={importFormat === 'json'} onChange={() => setImportFormat('json')} />
                        <span className="ml-1">JSON</span>
                      </label>
                      <label className="inline-flex items-center text-xs cursor-pointer">
                        <input type="radio" className="form-radio h-3 w-3 text-blue-600" name="sidebar-format" value="markdown" checked={importFormat === 'markdown'} onChange={() => setImportFormat('markdown')} />
                        <span className="ml-1">MD</span>
                      </label>
                    </div>
                </div>

                {/* Download Template Button */}
                <button
                  onClick={downloadTemplate}
                  className="w-full px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors text-xs"
                >
                  Download Template ({importFormat.toUpperCase()})
                </button>
              </div> {/* End of Sidebar Footer */}
          </div> {/* End of Sidebar div */}

          {/* Overlay for mobile when sidebar is open */}
           {sidebarOpen && <div className="fixed inset-0 bg-black bg-opacity-50 z-20 md:hidden" onClick={toggleSidebar}></div>}

          {/* Mobile sidebar toggle button (Hamburger) - Positioned relative to viewport */}
          {!sidebarOpen && (
             <button
              className="md:hidden fixed top-3 left-3 z-40 bg-blue-600 text-white p-2 rounded-md shadow-lg hover:bg-blue-700"
              onClick={toggleSidebar}
              aria-label="Open Menu"
             >
                ☰
             </button>
          )}


          {/* Main content Area */}
          {/* Adjust margin dynamically based on sidebar state for medium screens and up */}
          <div className={`flex-grow p-4 md:p-6 lg:p-8 overflow-y-auto main-content-transition ${sidebarOpen ? 'md:main-content-shifted' : 'md:main-content-unshifted'}`}>
             <div className="flex flex-col items-center min-h-full"> {/* Use min-h-full */}

                {/* Optional Header within main content (could be useful) */}
                 <div className="w-full max-w-4xl mb-4 flex justify-between items-center">
                    <h1 className="text-2xl font-bold text-gray-700">Virtual Flashcard App</h1>
                    {/* Maybe add some quick stats or controls here */}
                 </div>

                {/* Error & Notification Area */}
                <div className="w-full max-w-3xl mb-4 space-y-2">
                    {errorMessage && (
                      <div className="p-3 bg-red-100 text-red-700 rounded-lg text-sm flex justify-between items-center">
                         <span>{errorMessage}</span>
                         <button onClick={() => setErrorMessage('')} className="ml-2 text-red-500 hover:text-red-800 font-bold">✕</button>
                      </div>
                    )}
                    {notification && (
                      <div className="p-3 bg-green-100 text-green-700 rounded-lg text-sm flex justify-between items-center">
                        <span>{notification}</span>
                        <button onClick={() => setNotification('')} className="ml-2 text-green-500 hover:text-green-800 font-bold">✕</button>
                      </div>
                    )}
                </div>


                {/* Main Card and Controls Area */}
                <div className="w-full max-w-3xl">
                    {/* Controls (Category, Shuffle, Count) */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow flex flex-col md:flex-row justify-between items-center gap-3">
                      <div className="flex items-center w-full md:w-auto">
                        <label htmlFor="category-select" className="mr-2 text-sm font-medium text-gray-700 flex-shrink-0">Category:</label>
                        <select
                          id="category-select"
                          value={selectedCategory}
                          onChange={handleCategoryChange}
                          className="flex-grow p-2 border border-gray-300 rounded bg-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                          disabled={categories.length <= 1} // Disable if only 'All' exists
                        >
                          {categories.map((category, index) => (
                            <option key={index} value={category}>{category}</option>
                          ))}
                        </select>
                      </div>
                      <div className="flex items-center space-x-2 w-full md:w-auto justify-end">
                        <button
                          onClick={shuffleCards}
                          className="px-3 py-1.5 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors text-sm shadow disabled:opacity-50 disabled:cursor-not-allowed"
                          title="Shuffle cards in current category"
                          disabled={filteredCards.length < 2} // Disable if less than 2 cards
                        >
                          Shuffle
                        </button>
                        <span className="px-3 py-1.5 bg-gray-200 text-gray-700 rounded text-sm font-medium shadow-sm">
                          {filteredCards.length > 0 ? `${currentCardIndex + 1} / ${filteredCards.length}` : '0 / 0'}
                        </span>
                      </div>
                    </div>


                    {/* Flashcard Display */}
                    {filteredCards.length > 0 ? (
                      <div className="relative"> {/* Container for card and context */}
                          <div
                            className="w-full h-80 md:h-96 perspective-1000 mb-4 cursor-pointer group" // Added group for potential hover effects
                            onClick={flipCard}
                            role="button"
                            tabIndex="0" // Make it focusable
                            onKeyPress={(e) => { if (e.key === ' ' || e.key === 'Enter') flipCard(); }} // Flip on space/enter
                            aria-live="polite" // Announce changes
                            aria-label={`Flashcard ${currentCardIndex + 1} of ${filteredCards.length}. Currently showing ${isFlipped ? 'back' : 'front'}. Click or press space/enter to flip.`}
                          >
                            <div className={`relative w-full h-full transition-transform duration-500 transform-style-preserve-3d ${isFlipped ? 'rotate-y-180' : ''}`}>
                              {/* Card Front */}
                              <div className="card-front bg-white p-6 rounded-xl shadow-lg flex flex-col border border-gray-200">
                                 {/* Optional Subcategory/Context on Front */}
                                <div className="absolute top-3 left-3 text-xs text-gray-400 z-10"> {/* Ensure context is above content */}
                                  {filteredCards[currentCardIndex].category !== 'All' && filteredCards[currentCardIndex].category !== 'Uncategorized' && (
                                      <span className="bg-gray-100 px-1.5 py-0.5 rounded mr-1 shadow-sm">{filteredCards[currentCardIndex].category}</span>
                                  )}
                                   {filteredCards[currentCardIndex].subcategory && (
                                    <span className="bg-blue-100 text-blue-800 px-1.5 py-0.5 rounded shadow-sm">{filteredCards[currentCardIndex].subcategory}</span>
                                  )}
                                </div>

                                <div className="flex-grow flex items-center justify-center pt-6">
                                  {/* <<< APPLY CLASS HERE >>> */}
                                  <div className="text-xl md:text-2xl font-semibold text-center text-gray-800 break-words preserve-whitespace px-4"> {/* Added preserve-whitespace and padding */}
                                    {filteredCards[currentCardIndex].front}
                                  </div>
                                </div>
                                <div className="text-center text-gray-400 text-xs mt-4 group-hover:text-blue-500 flex-shrink-0">Click to flip</div>
                              </div>

                              {/* Card Back */}
                              <div className="card-back bg-blue-50 p-6 rounded-xl shadow-lg flex flex-col border border-blue-200">
                                <div className="flex-grow flex items-center justify-center overflow-y-auto py-4"> {/* Added padding */}
                                   {/* <<< APPLY CLASS HERE >>> */}
                                   {/* Apply to the container div */}
                                   <div className="text-base md:text-lg text-gray-900 preserve-whitespace px-4"> {/* Added preserve-whitespace and padding */}
                                    {filteredCards[currentCardIndex].back.split('\n').map((line, index, arr) => (
                                      // No need for class on each p if parent has it
                                      <p key={index} className={index === arr.length - 1 ? '' : 'mb-2'}>{line || '\u00A0'}</p> // Render empty lines as non-breaking space
                                    ))}
                                   </div>
                                </div>
                                <div className="text-center text-gray-500 text-xs mt-4 group-hover:text-blue-600 flex-shrink-0">Click to flip back</div>
                              </div>
                            </div>
                          </div>
                           {/* Context Display Below Card - Removed as it's now on card face */}
                          {/* {filteredCards[currentCardIndex]?.subcategory && (
                               <p className="text-center text-xs text-gray-500 italic mb-4">
                                  Subcategory: {filteredCards[currentCardIndex].subcategory}
                               </p>
                           )} */}
                      </div> // End card container
                    ) : (
                      <div className="text-center text-gray-500 mt-10 p-6 bg-white rounded-lg shadow min-h-[20rem] flex items-center justify-center"> {/* Added min-height */}
                           {activeFileIndex === -1 ? (
                               <span>No flashcard set loaded. Import a file using the sidebar.</span>
                           ) : (
                               <span>No cards match the selected category "{selectedCategory}". Try 'All' or import a different file.</span>
                           )}
                      </div>
                    )}

                    {/* Navigation Buttons */}
                    {filteredCards.length > 0 && (
                      <div className="flex justify-center space-x-4 mt-2">
                        <button
                          onClick={prevCard}
                          // disabled={currentCardIndex === 0} // Loop instead of disable
                          className={`px-5 py-2 rounded font-medium text-sm shadow transition-colors duration-150 bg-white text-blue-700 border border-blue-300 hover:bg-blue-50`}
                          aria-label="Previous Card"
                        >
                          Previous
                        </button>
                        <button
                          onClick={nextCard}
                          // disabled={currentCardIndex === filteredCards.length - 1} // Loop instead of disable
                          className={`px-5 py-2 rounded font-medium text-sm shadow transition-colors duration-150 bg-blue-600 text-white hover:bg-blue-700`}
                           aria-label="Next Card"
                        >
                          Next
                        </button>
                      </div>
                    )}
                </div> {/* End Main Card and Controls Area */}

                 {/* Footer Links */}
                 <div className="w-full max-w-3xl mt-8 pt-4 border-t border-gray-200 text-center text-xs text-gray-500">
                    <a href="https://github.com/cpickett101/VirtualStudyApp" target="_blank" rel="noopener noreferrer" className="hover:text-blue-600">GitHub Repository</a>
                    <span className="mx-2">|</span>
                    Created by <a href="https://www.linkedin.com/in/christopher-p-a4908979/" target="_blank" rel="noopener noreferrer" className="hover:text-blue-600">Christopher Pickett</a> - 2025
                 </div>

             </div> {/* End of flex flex-col items-center */}
          </div> {/* End of Main content div */}
        </div> // End of flex h-screen container
      );
    }; // End of App component

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
